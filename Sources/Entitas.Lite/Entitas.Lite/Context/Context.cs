using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using Entitas.Utils;

namespace Entitas {

	/// A context manages the lifecycle of entities and groups.
	/// You can create and destroy entities and get groups of entities.
	/// The prefered way to create a context is to use the generated methods
	/// from the code generator, e.g. var context = new GameContext();
	public partial class Context
	{
		/*
		/// Occurs when an entity gets created.
		public event ContextEntityChanged OnEntityCreated;

		/// Occurs when an entity will be destroyed.
		public event ContextEntityChanged OnEntityWillBeDestroyed;

		/// Occurs when an entity got destroyed.
		public event ContextEntityChanged OnEntityDestroyed;

		/// Occurs when a group gets created for the first time.
		public event ContextGroupChanged OnGroupCreated;
		*/

		/// The total amount of components an entity can possibly have.
		/// This value is generated by the code generator,
		/// e.g ComponentLookup.TotalComponents.
		public int totalComponents => _contextInfo.GetComponentCount();

		/// Returns all componentPools. componentPools is used to reuse
		/// removed components.
		/// Removed components will be pushed to the componentPool.
		/// Use entity.CreateComponent(index, type) to get a new or reusable
		/// component from the componentPool.
		//public Stack<IComponent>[] componentPools { get { return _componentPools; } }

		/// The contextInfo contains information about the context.
		/// It's used to provide better error messages.
		public ContextInfo contextInfo => _contextInfo;

		/// Returns the number of entities in the context.
		public int count => _entities.Count;

		/// Returns the number of entities in the internal ObjectPool
		/// for entities which can be reused.
		//public int reusableEntitiesCount { get { return _reusableEntities.Count; } }

		/// Returns the number of entities that are currently retained by
		/// other objects (e.g. Group, Collector, ReactiveSystem).
		//public int retainedEntitiesCount { get { return _retainedEntities.Count; } }

		//readonly int _totalComponents;

		private readonly IComponentPool[] _componentPools;
		private readonly ContextInfo _contextInfo;

		private readonly ConcurrentDictionary<int, Entity> _entities = new ConcurrentDictionary<int, Entity>();
		private readonly ConcurrentDictionary<Entity, byte> _changedEntities = new ConcurrentDictionary<Entity, byte>();
		private readonly EntityPool _entityPool = new EntityPool(256);

		//readonly HashSet<Entity> _entities = new HashSet<Entity>(EntityEqualityComparer.comparer);
		//readonly Stack<Entity> _reusableEntities = new Stack<Entity>();
		//readonly HashSet<Entity> _retainedEntities = new HashSet<Entity>(EntityEqualityComparer.comparer);

		//readonly Dictionary<string, IEntityIndex> _entityIndices;
		//readonly Dictionary<IMatcher, IGroup> _groups = new Dictionary<IMatcher, IGroup>();
		readonly List<IGroup>[] _groupsForIndex;
		readonly IGroup[] _groupForSingle;
		//readonly ObjectPool<List<GroupChanged>> _groupChangedListPool;

		private readonly Dictionary<Matcher, Group> _groups = new Dictionary<Matcher, Group>();


		int _creationIndex; 
		Entity[] _entitiesCache;

		// Cache delegates to avoid gc allocations
		EntityComponentChanged _cachedEntityChanged;
		//EntityComponentReplaced _cachedComponentReplaced;
		//EntityEvent _cachedEntityReleased;
		EntityEvent _cachedDestroyEntity;

		public static int maxRetainedComponentsInPool = 128;


		internal Context(ContextInfo contextInfo)
		{
			_contextInfo = contextInfo;
			_creationIndex = 0;

			int totalComponents = _contextInfo.GetComponentCount();

			_groupsForIndex = new List<IGroup>[totalComponents];
			_groupForSingle = new IGroup[totalComponents];
			
			_componentPools = new IComponentPool[totalComponents];

			for (int i = 0; i < totalComponents; i++)
				_componentPools[i] = ComponentPoolFactory.Create(contextInfo.componentTypes[i], maxRetainedComponentsInPool);


			/*
			_groupChangedListPool = new ObjectPool<List<GroupChanged>>(
										() => new List<GroupChanged>(),
										list => list.Clear()
									);
			*/

			// Cache delegates to avoid gc allocations
			_cachedEntityChanged = updateGroupsComponentAddedOrRemoved;
			_cachedComponentReplaced = updateGroupsComponentReplaced;
			_cachedEntityReleased = onEntityReleased;
			_cachedDestroyEntity = DestroyEntity;

			// Add listener for updating lookup
			//OnEntityCreated += (c, entity) => _entitiesLookup.Add(entity.creationIndex, (Entity)entity);
			//OnEntityDestroyed += (c, entity) => _entitiesLookup.Remove(entity.creationIndex);
		}

		/// Creates a new entity or gets a reusable entity from the
		/// internal ObjectPool for entities.
		public Entity CreateEntity(string name = null)
		{
			Interlocked.Increment(ref _creationIndex);

			var entity = _entityPool.Get();
			entity.Initialize(_contextInfo, _componentPools);
			entity.Start(_creationIndex, name);

			_entities.TryAdd(entity.id, entity); //TODO
			_entitiesCache = null;

			entity.OnComponentAdded += _cachedEntityChanged;
			entity.OnComponentRemoved += _cachedEntityChanged;
			//entity.OnComponentReplaced += _cachedComponentReplaced;
			//entity.OnEntityReleased += _cachedEntityReleased;
			entity.OnDestroyEntity += _cachedDestroyEntity;

			OnEntityCreated?.Invoke(this, entity);

			return entity;
		}

		/// Destroys the entity, removes all its components and pushs it back
		/// to the internal ObjectPool for entities.
		private void DestroyEntity(Entity entity)
		{
			if (!Contains(entity))
				return;

			_entities.TryRemove(entity.id, out var item);
			_entitiesCache = null;

			//OnEntityWillBeDestroyed?.Invoke(this, entity);
			entity.InternalDestroy();
			//OnEntityDestroyed?.Invoke(this, entity);

			// Add to changed list
			_changedEntities.TryAdd(entity, 0);
		}

		/// Destroys all entities in the context.
		/// Throws an exception if there are still retained entities.
		public void DestroyAllEntities()
		{
			var entities = GetEntities();
			for (int i = 0; i < entities.Length; i++)
				entities[i].Destroy();

			_entities.Clear();
		}

		/// Determines whether the context has the specified entity.
		public bool Contains(Entity entity)
		{
			if (entity == null)
				return false;

			if (!_entities.TryGetValue(entity.id, out var item))
				return false;

			return entity == item;
		}

		/// Returns entity matching the specified id
		public Entity GetEntity(int id)
		{
			_entities.TryGetValue(id, out var entity);
			return entity;
		}

		/// Returns all entities (NOT-sorted) currently in the context.
		public Entity[] GetEntities()
		{
			if (_entitiesCache == null)
				_entitiesCache = _entities.Values.ToArray();

			return _entitiesCache;
		}

		/// Returns a new collector
		public Collector CreateCollector()
		{
			return new Collector(this);
		}

		/// Returns a group for the specified matcher.
		/// Calling context.GetGroup(matcher) with the same matcher will always
		/// return the same instance of the group.
		public Group GetGroup(Matcher matcher)
		{
			if (!_groups.TryGetValue(matcher, out var group))
			{
				group = new Group(matcher);

				var entities = GetEntities();
				for (int i = 0; i < entities.Length; i++)
					group.HandleEntity(entities[i]);

				_groups.Add(matcher, group);

				/*
				for (int i = 0; i < matcher.indices.Length; i++)
				{
					var index = matcher.indices[i];

					if (_groupsForIndex[index] == null)
						_groupsForIndex[index] = new List<IGroup>();

					_groupsForIndex[index].Add(group);
				}
				*/

				OnGroupCreated?.Invoke(this, group);
			}

			return group;
		}

		/*
		/// Clears the componentPool at the specified index.
		public void ClearComponentPool(int index)
		{
			var componentPool = _componentPools[index];
			if (componentPool != null)
			{
				componentPool.Clear();
			}
		}

		/// Clears all componentPools.
		public void ClearComponentPools()
		{
			for (int i = 0; i < _componentPools.Length; i++)
			{
				ClearComponentPool(i);
			}
		}
		*/

		/// Resets the context (destroys all entities and
		/// resets creationIndex back to 0).
		public void Reset()
		{
			DestroyAllEntities();

			_creationIndex = 0;
			
			OnEntityCreated = null;
			OnEntityWillBeDestroyed = null;
			OnEntityDestroyed = null;
			//OnGroupCreated = null;
		}

		public override string ToString()
		{
			return _contextInfo.name;
		}

		/*
		void updateGroupsComponentAddedOrRemoved(IEntity entity, int index, IComponent component)
		{
			var groups = _groupsForIndex[index];
			if (groups != null)
			{
				var events = _groupChangedListPool.Get();

				var tEntity = (Entity)entity;

				for (int i = 0; i < groups.Count; i++)
				{
					events.Add(groups[i].HandleEntity(tEntity));
				}

				for (int i = 0; i < events.Count; i++)
				{
					var groupChangedEvent = events[i];
					if (groupChangedEvent != null)
					{
						groupChangedEvent(
							groups[i], tEntity, index, component
						);
					}
				}

				_groupChangedListPool.Push(events);
			}
		}
		*/

		/// <summary>
		/// Update all removed/changed entities, not thread-safe
		/// </summary>
		public void Poll()
		{
			// Take all changed entities
			var changedEntities = _changedEntities.Keys;
			_changedEntities.Clear();

			foreach (var entity in changedEntities)
			{
				if (entity == null)
					continue;

				// Update group content
				foreach (var kv in _groups)
					kv.Value?.HandleEntity(entity);

				// Return removed entity to pool
				if (!entity.isEnabled)
					_entityPool.Return(entity);
			}
		}

		/*
		void updateGroupsComponentReplaced(IEntity entity, int index, IComponent previousComponent, IComponent newComponent)
		{
			var groups = _groupsForIndex[index];
			if (groups != null)
			{

				var tEntity = (Entity)entity;

				for (int i = 0; i < groups.Count; i++)
				{
					groups[i].UpdateEntity(
						tEntity, index, previousComponent, newComponent
					);
				}
			}
		}
		*/

		/*
		void onEntityReleased(IEntity entity)
		{
			if (entity.isEnabled)
			{
				throw new EntityIsNotDestroyedException(
					"Cannot release " + entity + "!"
				);
			}
			var tEntity = (Entity)entity;
			entity.RemoveAllOnEntityReleasedHandlers();
			_retainedEntities.Remove(tEntity);
			_reusableEntities.Push(tEntity);
		}

		void onDestroyEntity(IEntity entity)
		{
			DestroyEntity((Entity)entity);
		}
		*/

		/*
		/// return unique entity with specified component
		public Entity GetSingleEntity<T>() where T : IComponent, IUnique {
			return GetSingleEntity(ComponentIndex<T>.value);
		}

		public Entity GetSingleEntity(int componentIndex) {
			IGroup group = _groupForSingle[componentIndex];

			if (group == null) {
				group = GetGroup(Matcher.AllOf(componentIndex).SetComponentNames(this.contextInfo.componentNames));
				_groupForSingle[componentIndex] = group;
			}

			return group.GetSingleEntity();
		}

		public T GetUnique<T>() where T : IComponent, IUnique {
			int componentIndex = ComponentIndex<T>.value;

			IComponent component = GetUniqueComponent(componentIndex);
			if (component == null)
				return default(T);

			return (T)component;
		}

		private IComponent GetUniqueComponent(int componentIndex) {
			Entity entity = GetSingleEntity(componentIndex);
			if (entity == null)
				return null;
			
			return entity.GetComponent(componentIndex);
		}

		public T AddUnique<T>(bool useExisted = true) where T : IComponent, IUnique, new() {
			int componentIndex = ComponentIndex<T>.value;

			Entity entity = GetSingleEntity(componentIndex);
			if (entity != null) {
				if (!useExisted)
					throw new EntityAlreadyHasComponentException(
					   componentIndex, "Cannot add component '" +
					   _contextInfo.componentNames[componentIndex] + "' to " + entity + "!",
					   "You should check if an entity already has the component."
					);
				return (T)ModifyUniqueComponent(componentIndex);
			}

			entity = CreateEntity(typeof(T).Name);
			T component = entity.CreateComponent<T>(componentIndex);
			entity.AddComponent(componentIndex, component);

			return component;
		}

		public T ModifyUnique<T>() where T : IComponent, IUnique {
			int componentIndex = ComponentIndex<T>.value;

			IComponent component = ModifyUniqueComponent(componentIndex);
			if (component == null)
				return default(T);

			return (T)component;
		}

		private IComponent ModifyUniqueComponent(int componentIndex) {
			Entity entity = GetSingleEntity(componentIndex);
			if (entity == null)
				return null;

			IComponent component = entity.GetComponent(componentIndex);
			entity.SetModified(componentIndex);
			return component;
		}
		*/
	}
}
